From cacb9ac7f9b251f3e66783b49a6329ac7c1fd21b Mon Sep 17 00:00:00 2001
From: soulteary <soulteary@gmail.com>
Date: Fri, 7 May 2021 15:38:48 +0800
Subject: [PATCH] async add bookmarks for ext

---
 internal/webserver/handler-api-ext.go | 78 ++++++++++++++-------------
 1 file changed, 40 insertions(+), 38 deletions(-)

diff --git a/internal/webserver/handler-api-ext.go b/internal/webserver/handler-api-ext.go
index 1948731..adec32d 100644
--- a/internal/webserver/handler-api-ext.go
+++ b/internal/webserver/handler-api-ext.go
@@ -57,53 +57,55 @@ func (h *handler) apiInsertViaExtension(w http.ResponseWriter, r *http.Request,
 		}
 	}
 
-	// Since we are using extension, the extension might send the HTML content
-	// so no need to download it again here. However, if it's empty, it might be not HTML file
-	// so we download it here.
-	var contentType string
-	var contentBuffer io.Reader
-
-	if book.HTML == "" {
-		contentBuffer, contentType, _ = core.DownloadBookmark(book.URL)
-	} else {
-		contentType = "text/html; charset=UTF-8"
-		contentBuffer = bytes.NewBufferString(book.HTML)
-	}
-
-	// At this point the web page already downloaded.
-	// Time to process it.
-	if contentBuffer != nil {
-		book.CreateArchive = true
-		request := core.ProcessRequest{
-			DataDir:     h.DataDir,
-			Bookmark:    book,
-			Content:     contentBuffer,
-			ContentType: contentType,
+	go func(){
+		// Since we are using extension, the extension might send the HTML content
+		// so no need to download it again here. However, if it's empty, it might be not HTML file
+		// so we download it here.
+		var contentType string
+		var contentBuffer io.Reader
+
+		if book.HTML == "" {
+			contentBuffer, contentType, _ = core.DownloadBookmark(book.URL)
+		} else {
+			contentType = "text/html; charset=UTF-8"
+			contentBuffer = bytes.NewBufferString(book.HTML)
 		}
 
-		var isFatalErr bool
-		book, isFatalErr, err = core.ProcessBookmark(request)
+		// At this point the web page already downloaded.
+		// Time to process it.
+		if contentBuffer != nil {
+			book.CreateArchive = true
+			request := core.ProcessRequest{
+				DataDir:     h.DataDir,
+				Bookmark:    book,
+				Content:     contentBuffer,
+				ContentType: contentType,
+			}
 
-		if tmp, ok := contentBuffer.(io.ReadCloser); ok {
-			tmp.Close()
-		}
+			var isFatalErr bool
+			book, isFatalErr, err = core.ProcessBookmark(request)
+
+			if tmp, ok := contentBuffer.(io.ReadCloser); ok {
+				tmp.Close()
+			}
 
-		if err != nil && isFatalErr {
-			panic(fmt.Errorf("failed to process bookmark: %v", err))
+			if err != nil && isFatalErr {
+				fmt.Errorf("failed to process bookmark: %v", err)
+				return
+			}
 		}
-	}
 
-	// Save bookmark to database
-	results, err := h.DB.SaveBookmarks(book)
-	if err != nil || len(results) == 0 {
-		panic(fmt.Errorf("failed to save bookmark: %v", err))
-	}
-	book = results[0]
+		// Save bookmark to database
+		results, err := h.DB.SaveBookmarks(book)
+		if err != nil || len(results) == 0 {
+			fmt.Errorf("failed to save bookmark: %v", err)
+			return
+		}
+	}()
 
 	// Return the new bookmark
 	w.Header().Set("Content-Type", "application/json")
-	err = json.NewEncoder(w).Encode(&book)
-	checkError(err)
+	w.Write([]byte(`{"code":201}`))
 }
 
 // apiDeleteViaExtension is handler for DELETE /api/bookmark/ext
